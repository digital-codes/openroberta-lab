include: "classpath:/common.methods.yml"

## FunctionNames

OMNIDRIVESPEED:
  PYTHON: |
    def setSpeedOmnidrivePercent(x, y, z):
        global currentSpeed
        currentSpeed[0] = (1 / 100 * x) * MAXSPEED
        currentSpeed[1] = (1 / 100 * y) * MAXSPEED
        currentSpeed[2] = 1 / 100 * z * MAXSPEED

POSTVEL:
  PYTHON: |
    def postVel():
        OMNIDRIVE_URL = "http://" + ROBOTINOIP + "/data/omnidrive"
        r = requests.post(url = OMNIDRIVE_URL, params = PARAMS, json = currentSpeed )

GETDISTANCE:
  PYTHON: |
    def getDistance(port):
        DISTANCES_URL = "http://" + ROBOTINOIP + "/data/distancesensorarray"
        r = requests.get(url = DISTANCES_URL, params = PARAMS)
        if r.status_code == requests.codes.ok:
            data = r.json()
            return data[port-1] * 100
        else:
            return -1

ISBUMPED:
  PYTHON: |
    def isBumped():
        BUMPER_URL = "http://" + ROBOTINOIP + "/data/bumper"
        r = requests.get(url = BUMPER_URL, params = PARAMS)
        if r.status_code == requests.codes.ok:
            data = r.json()
            return data["value"]
        else:
            return -1

SETDIGITALPIN:
  PYTHON: |
    def setDigitalPin(pos, value):
        global _digitalPinValues
        _digitalPinValues[pos-1] = int(value)
        DIGITALPIN_URL = "http://" + ROBOTINOIP + "/data/digitaloutputarray"
        r = requests.post(url = DIGITALPIN_URL, params = PARAMS, json = _digitalPinValues )

GETDIGITALPIN:
  PYTHON: |
    def getDigitalPin(pos):
        DIGITALPIN_URL = "http://" + ROBOTINOIP + "/data/digitalinputarray"
        r = requests.get(url = DIGITALPIN_URL, params = PARAMS)
        if r.status_code == requests.codes.ok:
            data = r.json()
            return data[pos-1]
        else:
            return -1

GETANALOGPIN:
  PYTHON: |
    def getAnalogPin(pos):
        ANALOGPIN_URL = "http://" + ROBOTINOIP + "/data/analoginputarray"
        r = requests.get(url = ANALOGPIN_URL, params = PARAMS)
        if r.status_code == requests.codes.ok:
            data = r.json()
            return data[pos-1]
        else:
            return -1

GETODOMETRY:
  PYTHON: |
    def getOdometry(val):
        ODOMETRY_URL = "http://" + ROBOTINOIP + "/data/odometry"
        r = requests.get(url = ODOMETRY_URL, params = PARAMS)
        if r.status_code == requests.codes.ok:
            data = r.json()
            #data: [x,y,rot,vx,vy,omega,seq]
            if val == 'x':
                return data[0]
            elif val == 'y':
                return data[1]
            elif val == 'rot':
                return data[2]
            else:
                return data
        else:
            return -1

RESETODOMETRY:
  PYTHON: |
    def resetOdometry(RV, x, y, z):
        RV.writeFloatVector(1, [x, y, z, 1])
        time.sleep(0.1)
        RV.writeFloatVector(1, [])

GETDIRECTION:
  PYTHON: |
    def getDirection(xTarget, yTarget, speed):
         vectorX = xTarget - getOdometry("x") * 100
         vectorY = yTarget - getOdometry("y") * 100
         absV = math.sqrt(math.pow(vectorX, 2) + math.pow(vectorY, 2))
         maxSpeedX = (vectorX / absV)
         maxSpeedY = (vectorY / absV)
         angle = - getOdometry("rot")
         rotatedX = (math.cos(angle) * maxSpeedX) - (math.sin(angle) * maxSpeedY)
         rotatedY = (math.sin(angle) * maxSpeedX + math.cos(angle) * maxSpeedY)
         return rotatedX * speed, rotatedY * speed

DRIVETOPOSITION:
  PYTHON: |
    def driveToPosition(xTarget, yTarget, speed):
        firstPositionX, firstPositionY = getOdometry("x"), getOdometry("y")
        tolerance = 20 * speed/100  
        while not isBumped():
            speedX, speedY = getDirection(xTarget, yTarget, speed)
            xPos, yPos = getOdometry("x"), getOdometry("y")
            diffx = abs(xPos - xTarget)
            diffy = abs(xPos - yTarget)
            if diffx <= tolerance and diffy <= tolerance:
                speedX = speedX * diffx/tolerance
                speedY = speedY * diffy/tolerance
            setSpeedOmnidrivePercent(speedX, speedY, 0)

            if firstPositionX >= xTarget >= xPos or firstPositionX < xTarget <= xPos:
                if firstPositionY >= yTarget >= yPos or firstPositionY < yTarget <= yPos:
                    break
        setSpeedOmnidrivePercent(0, 0, 0)

DRIVEFORDISTANCE:
  PYTHON: |
    def driveForDistance(x, y, distance):
        distance = distance
        angle = math.atan2(y,  x)
        targetX = getOdometry("x") + distance * math.cos(angle)
        targetY = getOdometry("y") + distance * math.sin(angle)
        resultingSpeed = math.sqrt(math.pow(x,2) + math.pow(y,2))
        driveToPosition(targetX, targetY, resultingSpeed)

TURNFORDEGREES:
  PYTHON: |
    def turnForDegrees(RV, speed, degrees):
        if degrees < 0:
            speed = speed * -1
        distance = abs(degrees)
        lastOrientation = RV.readFloatVector(1)[2]
        setSpeedOmnidrivePercent(0, 0, speed)
        while distance > 0:
            orientation = RV.readFloatVector(1)[2]
            traveledDegrees = abs(orientation - lastOrientation)
            if ((speed > 0 and lastOrientation > orientation) or (speed < 0 and lastOrientation < orientation)) and traveledDegrees > 300:
                traveledDegrees = 360 - traveledDegrees
            distance -= traveledDegrees
            lastOrientation = orientation
            time.sleep(0.05)
        setSpeedOmnidrivePercent(0, 0, 0)

GETMARKERINFO:
  PYTHON: |
    def getMarkerInformation(RV, id):
        RV.writeFloat(3,id)
        time.sleep(0.001)
        value = RV.readFloatVector(4) 
        if not value[0]:
            value = [False, -1,-1,-1,-1,-1,-1]
        else:
            for i in range (1,4):
                value[i] = value[i] * 100  
        return value[1:4]

GETCOLOURBLOB:
  PYTHON: |
    def getColourBlob(RV, inputs):
        RV.writeFloatVector(6, inputs)
        time.sleep(0.001)
        value = RV.readFloatVector(6)
        if value[3] <= 0:
            value = [-1,-1,0,0]
        return value

GETCAMERALINE:
  PYTHON: |
    def getCameraLine(RV):
        value = RV.readFloatVector(5)
        if value[0]:
            return value[1]
        else:
            return -1
